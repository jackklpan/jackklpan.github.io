<!DOCTYPE html>
<html>

<head>
  <title></title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
  <script src="https://unpkg.com/typeit@8.7.1/dist/index.umd.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100..900&display=swap" rel="stylesheet">
</head>

<body>
  <style>
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f0f0f0;
    }

    .container {
      /* Light grey background */
      font-family: "Noto Sans TC", sans-serif;
      font-optical-sizing: auto;
      font-style: normal;
      font-weight: 350;
      line-height: 1.6;
      color: #333;
      /* Dark grey text */
      max-width: 90%;
      margin: 20px;
      padding: 20px;
      border-radius: 10px;
      background: #fff;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      max-height: 90vh;
      /* Ensure it doesn't overflow the viewport */
    }

    .proposal-text {
      font-size: 1em;
      text-align: justify;
    }

    @media (min-width: 600px) {
      .proposal-text {
        font-size: 1.2em;
        /* Larger text for bigger screens */
      }
    }

    html,
    body,
    #map {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100vw;
      z-index: -1;
    }

    .custom-div-icon {
      display: flex;
      align-items: center;
    }

    .custom-div-icon .label {
      margin-left: 5px;
      padding: 2px 5px;
      border-radius: 3px;
      background-color: white;
    }

    .info {
      padding: 6px 8px;
      font: 14px/16px Arial, Helvetica, sans-serif;
      background: white;
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      border-radius: 5px;
    }

    .info h4 {
      margin: 0 0 5px;
      color: #777;
    }
  </style>
  <audio id="audio">
    <source src="song.mp3" type="audio/mpeg">
  </audio>
  <div id="map" style="width: 100%; height: 100%;"></div>
  <div class="container" style="display: none">
    <div id="proposalText" class="proposal-text"></div>
  </div>
  <script>
    const map = L.map('map').setView([25.0275, 121.5251], 14); // Center the map around Taipei
    let routeLines = [];
    let markers = [];
    let infos = [];

    L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
      maxZoom: 19,
    }).addTo(map);

    proj4.defs("EPSG:3826", "+proj=tmerc +lat_0=0 +lon_0=121 +k=1 +x_0=250000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
    const fromProjection = "EPSG:3826";
    const toProjection = "EPSG:4326";

    // Define custom icon
    const whiteCircleIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32"><circle cx="16" cy="16" r="16" fill="white" stroke="black" stroke-width="1" /></svg>'),
      iconSize: [24, 24], // size of the icon
      iconAnchor: [12, 12], // point of the icon which will correspond to marker's location
    });
    const pinkCircleIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32"><circle cx="16" cy="16" r="16" fill="#F7D5DF" stroke="black" stroke-width="1" /></svg>'),
      iconSize: [24, 24], // size of the icon
      iconAnchor: [12, 12], // point of the icon which will correspond to marker's location
    });
    const redCircleIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32"><circle cx="16" cy="16" r="16" fill="red" stroke="black" stroke-width="1" /></svg>'),
      iconSize: [24, 24], // size of the icon
      iconAnchor: [12, 12], // point of the icon which will correspond to marker's location
    });
    const orangeCircleIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32"><circle cx="16" cy="16" r="16" fill="orange" stroke="black" stroke-width="1" /></svg>'),
      iconSize: [24, 24], // size of the icon
      iconAnchor: [12, 12], // point of the icon which will correspond to marker's location
    });
    const yellowCircleIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32"><circle cx="16" cy="16" r="16" fill="#FFEF9F" stroke="black" stroke-width="1" /></svg>'),
      iconSize: [24, 24], // size of the icon
      iconAnchor: [12, 12], // point of the icon which will correspond to marker's location
    });

    function pointCircleIcon(pointName) {
      switch (pointName) {
        case 'æ¾æ±Ÿå—äº¬ç«™':
        case 'å—äº¬å¾©èˆˆç«™':
        case 'å¿ å­å¾©èˆˆç«™':
        case 'å¿ å­æ–°ç”Ÿç«™':
        case 'å¤§å®‰æ£®æ—å…¬åœ’ç«™':
        case 'å¤§å®‰ç«™': return pinkCircleIcon;
        case 'æ¿æ©‹ç«™':
        case 'åºœä¸­ç«™':
        case 'æ–°åŸ”ç«™': return redCircleIcon;
        case 'å°åŒ—è»Šç«™':
        case 'è‡ºå¤§é†«é™¢ç«™':
        case 'å°å—é–€ç«™':
        case 'è¥¿é–€ç«™': return orangeCircleIcon;
        case 'æ°¸æ˜¥ç«™':
        case 'æ¾å±±ç«™': return yellowCircleIcon;
        default: return whiteCircleIcon;
      }
    }

    function clickMarkerHandler(e, feature) {
      switch (feature.properties.NAME) {
        case 'æ¾æ±Ÿå—äº¬ç«™':
        case 'å—äº¬å¾©èˆˆç«™':
        case 'å¿ å­å¾©èˆˆç«™':
        case 'å¿ å­æ–°ç”Ÿç«™':
        case 'å¤§å®‰æ£®æ—å…¬åœ’ç«™':
        case 'å¤§å®‰ç«™':
        case 'æ¿æ©‹ç«™':
        case 'åºœä¸­ç«™':
        case 'æ–°åŸ”ç«™':
        case 'å°åŒ—è»Šç«™':
        case 'è‡ºå¤§é†«é™¢ç«™':
        case 'å°å—é–€ç«™':
        case 'è¥¿é–€ç«™':
        case 'æ°¸æ˜¥ç«™':
        case 'æ¾å±±ç«™': {
          let answer = prompt("è«‹è¼¸å…¥ç­”æ¡ˆï¼š");
          if (answer === '1021') {
            alert("ç­”å°äº†ï¼");
            markers.forEach(marker => {
              if (map.hasLayer(marker)) {
                map.removeLayer(marker);
              }
            })
            routeLines.forEach(route => {
              if (map.hasLayer(route)) {
                map.removeLayer(route);
              }
            })
            infos.forEach(info => {
              map.removeControl(info);
            })
            document.getElementById('audio').play();
            document.querySelector('.container').style.display = 'block';
            new TypeIt("#proposalText", {
              speed: 50,
              waitUntilVisible: true,
              afterStep: function (instance) {
                const container = document.querySelector('.container');
                container.scrollTop = container.scrollHeight;
              }
            }).type("ç™½ç™½", { delay: 3000 })
              .type("<br />ä»Šå¤©æ˜¯æˆ‘å€‘åœ¨ä¸€èµ·çš„ç¬¬ä¸€åƒä¸‰ç™¾å››åäº”å¤©ï¼Œ", { delay: 1000 })
              .type("<br />åœ¨é€™ç¸®å°çš„åœ°åœ–ä¸Šï¼Œ", { delay: 1000 })
              .type("<br />æœ‰å¥½å¤šå¥½å¤šæˆ‘å€‘çš„è¶³è·¡ï¼Œ", { delay: 1000 })
              .type("<br />å–œæ­¡é€™äº›è·Ÿä½ çš„è¶³è·¡ï¼Œ", { delay: 1000 })
              .type("<br />ä¸€èµ·ç´¯ç©å‡ºä¾†çš„ç¾å¥½å›æ†¶â¤ï¸", { delay: 2000 })
              .type("<br />æˆ‘å€‘åœ¨è¥¿é–€ç”ºçœ‹é›»å½±ï¼Œ", { delay: 1000 })
              .type("<br />æˆ‘å€‘åœ¨æ¾å±±ç«™ç‰½èµ·å½¼æ­¤çš„æ‰‹ï¼Œ", { delay: 1000 })
              .type("<br />æˆ‘å€‘åœ¨åºœä¸­ç«™åº¦éäº†è¨±å¤šçš„ç¬¬ä¸€æ¬¡ã€‚", { delay: 1000 })
              .type("<br />åæœˆäºŒåä¸€è™Ÿæ˜¯ä¸€å€‹å±¬æ–¼æˆ‘å€‘çš„æ—¥å­ï¼Œ", { delay: 1000 })
              .type("<br />ç™½ç™½", { delay: 2000 })
              .move(-2)
              .type("æœªå©šå¦»", { delay: 2000 })
              .move(5)
              .type("â¤ï¸", { delay: 1000 })
              .type("<br />æˆ‘æƒ³å’Œä½ ä¸€èµ·ï¼Œ", { delay: 1000 })
              .type("<br />è®“æˆ‘å€‘çš„è¶³è·¡èˆ‡å›æ†¶å»¶ä¼¸ï¼Œ", { delay: 1000 })
              .type("<br />ä¸€èµ·é‚å…¥ä¸‹ä¸€æ®µæ—…ç¨‹ï¼Œ", { delay: 1000 })
              .type("<br />ä¸€èµ·èµ°åˆ°æ°¸é ã€‚", { delay: 1000 })
              .type("<br />", { delay: 1000 })
              .type("<br />ç™½ç™½ï¼Œ", { delay: 1000 })
              .type("<br />æˆ‘æ„›ä½ ï¼", { delay: 2000 })
              .type("<br />", { delay: 2000 })
              .type("<br />", { delay: 2000 })
              .type("å¦³é¡˜æ„å«çµ¦æˆ‘å—ğŸ¥¹", { delay: 2000 })
              .type("<br />", { delay: 1000 })
              .type("<br />ç¶¸ç¶¸", { delay: 1000 })
              .go();
          } else {
            alert("ã„‰ã„Ÿã„‰ã„Ÿ");
          }
        }
      }
    }

    fetch('TpeMrtStations_TWD97_FIDCODE.json')
      .then(response => response.json())
      .then(data => {
        data.features.forEach(feature => {
          const coords = feature.geometry.coordinates;
          const [lng, lat] = proj4(fromProjection, toProjection, coords);

          const mainMarker = L.marker([lat, lng], { icon: pointCircleIcon(feature.properties.NAME) }).addTo(map).on('click', function (e) {
            clickMarkerHandler(e, feature);
          });

          markers.push(mainMarker);
        });
      });

    // Load route lines
    // Function to validate and transform coordinates
    function transformCoords(coords) {
      if (Array.isArray(coords) && coords.length === 2 && isFinite(coords[0]) && isFinite(coords[1])) {
        const [lng, lat] = proj4(fromProjection, toProjection, coords);
        return [lat, lng];
      } else {
        console.error('Invalid coordinates:', coords);
        return null;
      }
    }

    // Process LineString coordinates
    function processLineString(coords) {
      return coords.map(coord => transformCoords(coord)).filter(Boolean);
    }

    // Process MultiLineString coordinates
    function processMultiLineString(coordsArray) {
      return coordsArray.map(coords => processLineString(coords));
    }

    function routeColor(routeName) {
      switch (routeName) {
        case 'ä¿¡ç¾©ç·š':
        case 'æ·¡æ°´ç·š': return "#f9000f";
        case 'æœ¨æŸµç·š':
        case 'å…§æ¹–ç·š': return "#ce8d13";
        case 'è˜†æ´²ç·š':
        case 'æ–°èŠç·š':
        case 'ä¸­å’Œç·š': return '#ffb600';
        case 'æ¿æ©‹ç·š':
        case 'å—æ¸¯ç·š': return '#006bc2';
        case 'å°å—é–€ç·š':
        case 'æ¾å±±ç·š':
        case 'æ–°åº—ç·š': return '#008c5a';
        case 'ç¢§æ½­æ”¯ç·š': return '#d0e300';
        case 'ç’°ç‹€ç·š': return '#fed631';
        default: console.log("Couldn't Identify " + routeName); return "#d0e300";
      }
    }

    fetch('TpeMRTRoutes_TWD97-121208.json')
      .then(response => response.json())
      .then(data => {
        data.features.forEach(feature => {
          const geometry = feature.geometry;
          let coords;

          if (geometry.type === "LineString") {
            coords = processLineString(geometry.coordinates);
            if (coords.length > 0) {
              const route = L.polyline(coords, { color: routeColor(feature.properties.RouteName) }).addTo(map);
              routeLines.push(route);
            }
          } else if (geometry.type === "MultiLineString") {
            coords = processMultiLineString(geometry.coordinates);
            coords.forEach(line => {
              if (line.length > 0) {
                const route = L.polyline(line, { color: routeColor(feature.properties.RouteName) }).addTo(map);
                routeLines.push(route);
              }
            });
          } else {
            console.error('Unsupported geometry type:', geometry.type);
          }
        });
      });

    var info = L.control();
    info.onAdd = function (map) {
      this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
      this._div.innerHTML = '<h4>è¬é¡Œ</h4> <span>æˆ‘æœ€æ„›çš„ç™½ç™½ï¼Œ<br />æ„Ÿè¬æˆ‘å€‘ç•¶åˆå‹‡æ•¢åœ°ä¼¸å‡ºæ‰‹æ¡ä½å½¼æ­¤ï¼Œ<br />æˆç‚ºå½¼æ­¤çš„å…‰ï¼Œé™¤äº†ç…§äº®è‡ªå·±ï¼Œä¹Ÿç…§äº®å°æ–¹ã€‚<br />å¸Œæœ›é€™æ¬¡çš„éŠæˆ²ä½ ç©å¾—é–‹å¿ƒï¼</span>';
      return this._div;
    };
    info.addTo(map);

    infos.push(info);
  </script>
</body>

</html>